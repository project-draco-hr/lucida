{
  Semiring semiring=fst.getSemiring();
  HashMap<String,Path> finalPaths=new HashMap<String,Path>();
  HashMap<State,Path> paths=new HashMap<State,Path>();
  Queue<State> queue=new LinkedList<State>();
  Path p=new Path(fst.getSemiring());
  p.setCost(semiring.one());
  paths.put(fst.getStart(),p);
  queue.add(fst.getStart());
  String[] osyms=fst.getOsyms();
  while (!queue.isEmpty()) {
    State s=queue.remove();
    Path currentPath=paths.get(s);
    if (s.getFinalWeight() != semiring.zero()) {
      String pathString=currentPath.getPath().toString();
      if (finalPaths.containsKey(pathString)) {
        Path old=finalPaths.get(pathString);
        if (old.getCost() > currentPath.getCost()) {
          finalPaths.put(pathString,currentPath);
        }
      }
 else {
        finalPaths.put(pathString,currentPath);
      }
    }
    int numArcs=s.getNumArcs();
    for (int j=0; j < numArcs; j++) {
      Arc a=s.getArc(j);
      p=new Path(fst.getSemiring());
      Path cur=paths.get(s);
      p.setCost(cur.getCost());
      p.setPath((ArrayList<String>)cur.getPath().clone());
      String sym=osyms[a.getOlabel()];
      String[] symsArray=sym.split("\\" + tie);
      for (int i=0; i < symsArray.length; i++) {
        String phone=symsArray[i];
        if (!skipSeqs.contains(phone)) {
          p.getPath().add(phone);
        }
      }
      p.setCost(semiring.times(p.getCost(),a.getWeight()));
      State nextState=a.getNextState();
      paths.put(nextState,p);
      if (!queue.contains(nextState)) {
        queue.add(nextState);
      }
    }
  }
  ArrayList<Path> res=new ArrayList<Path>();
  for (  Path path : finalPaths.values()) {
    res.add(path);
  }
  Collections.sort(res,new PathComparator());
  int numPaths=res.size();
  for (int i=nbest; i < numPaths; i++) {
    res.remove(res.size() - 1);
  }
  return res;
}
