def create_pipeline(self, conf):
    self.appsrc = Gst.ElementFactory.make('appsrc', 'appsrc')
    self.decodebin = Gst.ElementFactory.make('decodebin', 'decodebin')
    self.audioconvert = Gst.ElementFactory.make('audioconvert', 'audioconvert')
    self.audioresample = Gst.ElementFactory.make('audioresample', 'audioresample')
    self.tee = Gst.ElementFactory.make('tee', 'tee')
    self.queue1 = Gst.ElementFactory.make('queue', 'queue1')
    self.filesink = Gst.ElementFactory.make('filesink', 'filesink')
    self.queue2 = Gst.ElementFactory.make('queue', 'queue2')
    self.cutter = Gst.ElementFactory.make('cutter', 'cutter')
    self.asr = Gst.ElementFactory.make('onlinegmmdecodefaster', 'asr')
    self.fakesink = Gst.ElementFactory.make('fakesink', 'fakesink')
    for (key, val) in conf.get('decoder', {}).iteritems():
        logger.info(('Setting decoder property: %s = %s' % (key, val)))
        self.asr.set_property(key, val)
    self.appsrc.set_property('is-live', True)
    self.filesink.set_property('location', '/dev/null')
    self.cutter.set_property('leaky', False)
    self.cutter.set_property('pre-length', (1000 * 1000000))
    self.cutter.set_property('run-length', (1000 * 1000000))
    self.cutter.set_property('threshold', 0.01)
    if self.use_cutter:
        self.asr.set_property('silent', True)
    logger.info('Created GStreamer elements')
    self.pipeline = Gst.Pipeline()
    for element in [self.appsrc, self.decodebin, self.audioconvert, self.audioresample, self.tee, self.queue1, self.filesink, self.queue2, self.cutter, self.asr, self.fakesink]:
        logger.debug(('Adding %s to the pipeline' % element))
        self.pipeline.add(element)
    logger.info('Linking GStreamer elements')
    self.appsrc.link(self.decodebin)
    self.decodebin.connect('pad-added', self._connect_decoder)
    if self.use_cutter:
        self.cutter.link(self.audioconvert)
    self.audioconvert.link(self.audioresample)
    self.audioresample.link(self.tee)
    self.tee.link(self.queue1)
    self.queue1.link(self.filesink)
    self.tee.link(self.queue2)
    self.queue2.link(self.asr)
    self.asr.link(self.fakesink)
    self.bus = self.pipeline.get_bus()
    self.bus.add_signal_watch()
    self.bus.enable_sync_message_emission()
    self.bus.connect('message::eos', self._on_eos)
    self.bus.connect('message::error', self._on_error)
    cutter_type = 'sync'
    if (cutter_type == 'async'):
        self.bus.connect('message::element', self._on_element_message)
    else:
        self.bus.connect('sync-message::element', self._on_element_message)
    self.asr.connect('hyp-word', self._on_word)
    logger.info('Setting pipeline to READY')
    self.pipeline.set_state(Gst.State.READY)
    logger.info('Set pipeline to READY')
