def do_collect_tests(servers, clients):

    def intersection(key, o1, o2):
        'intersection of two collections.\n    collections are replaced with sets the first time'

        def cached_set(o, key):
            v = o[key]
            if (not isinstance(v, set)):
                v = set(v)
                o[key] = v
            return v
        return (cached_set(o1, key) & cached_set(o2, key))

    def intersect_with_spec(key, o1, o2):

        def cached_set(o):

            def to_spec_impl_tuples(values):
                for v in values:
                    (spec, _, impl) = v.partition(':')
                    yield (spec, (impl or spec))
            v = o[key]
            if (not isinstance(v, set)):
                v = set(to_spec_impl_tuples(set(v)))
                o[key] = v
            return v
        for (spec1, impl1) in cached_set(o1):
            for (spec2, impl2) in cached_set(o2):
                if (spec1 == spec2):
                    name = (impl1 if (impl1 == impl2) else ('%s-%s' % (impl1, impl2)))
                    yield (name, impl1, impl2)

    def maybe_max(key, o1, o2, default):
        'maximum of two if present, otherwise defult value'
        v1 = o1.get(key)
        v2 = o2.get(key)
        return (max(v1, v2) if (v1 and v2) else (v1 or v2 or default))

    def filter_with_validkeys(o):
        ret = {}
        for key in VALID_JSON_KEYS:
            if (key in o):
                ret[key] = o[key]
        return ret

    def merge_metadata(o, **ret):
        for key in VALID_JSON_KEYS:
            if (key in o):
                ret[key] = o[key]
        return ret
    for (sv, cl) in product(servers, clients):
        for (proto, proto1, proto2) in intersect_with_spec('protocols', sv, cl):
            for (trans, trans1, trans2) in intersect_with_spec('transports', sv, cl):
                for sock in intersection('sockets', sv, cl):
                    yield {'server': merge_metadata(sv, **{'protocol': proto1, 'transport': trans1, }), 'client': merge_metadata(cl, **{'protocol': proto2, 'transport': trans2, }), 'delay': maybe_max('delay', sv, cl, DEFAULT_DELAY), 'timeout': maybe_max('timeout', sv, cl, DEFAULT_TIMEOUT), 'protocol': proto, 'transport': trans, 'socket': sock, }
