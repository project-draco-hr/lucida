def _integrate_cycle(self, cycle, outevent, inevent):
    if (outevent not in cycle):
        total = inevent.null()
        for member in cycle.functions:
            subtotal = member[inevent]
            for call in compat_itervalues(member.calls):
                callee = self.functions[call.callee_id]
                if (callee.cycle is not cycle):
                    subtotal += self._integrate_call(call, outevent, inevent)
            total += subtotal
        cycle[outevent] = total
        callees = {}
        for function in compat_itervalues(self.functions):
            if (function.cycle is not cycle):
                for call in compat_itervalues(function.calls):
                    callee = self.functions[call.callee_id]
                    if (callee.cycle is cycle):
                        try:
                            callees[callee] += call.ratio
                        except KeyError:
                            callees[callee] = call.ratio
        for member in cycle.functions:
            member[outevent] = outevent.null()
        for (callee, call_ratio) in compat_iteritems(callees):
            ranks = {}
            call_ratios = {}
            partials = {}
            self._rank_cycle_function(cycle, callee, 0, ranks)
            self._call_ratios_cycle(cycle, callee, ranks, call_ratios, set())
            partial = self._integrate_cycle_function(cycle, callee, call_ratio, partials, ranks, call_ratios, outevent, inevent)
            assert (partial == max(partials.values()))
            assert ((not total) or (abs((1.0 - (partial / (call_ratio * total)))) <= 0.001))
    return cycle[outevent]
