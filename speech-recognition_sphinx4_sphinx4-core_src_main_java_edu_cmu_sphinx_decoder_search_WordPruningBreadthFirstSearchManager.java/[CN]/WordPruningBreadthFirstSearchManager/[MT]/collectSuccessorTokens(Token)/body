{
  if (token.isFinal()) {
    resultList.add(getResultListPredecessor(token));
    return;
  }
  if (!token.isEmitting() && (keepAllTokens && isVisited(token))) {
    return;
  }
  SearchState state=token.getSearchState();
  SearchStateArc[] arcs=state.getSuccessors();
  Token predecessor=getResultListPredecessor(token);
  for (  SearchStateArc arc : arcs) {
    SearchState nextState=arc.getState();
    if (checkStateOrder) {
      checkStateOrder(state,nextState);
    }
    float logEntryScore=token.getScore() + arc.getProbability();
    Token bestToken=getBestToken(nextState);
    boolean firstToken=bestToken == null;
    if (firstToken || bestToken.getScore() < logEntryScore) {
      Token newBestToken=new Token(predecessor,nextState,logEntryScore,arc.getInsertionProbability(),arc.getLanguageProbability(),currentFrameNumber);
      tokensCreated.value++;
      setBestToken(newBestToken,nextState);
      if (firstToken) {
        activeListAdd(newBestToken);
      }
 else {
        activeListReplace(bestToken,newBestToken);
        if (buildWordLattice && newBestToken.isWord()) {
          loserManager.changeSuccessor(newBestToken,bestToken);
          loserManager.addAlternatePredecessor(newBestToken,bestToken.getPredecessor());
        }
      }
    }
 else {
      if (buildWordLattice && nextState instanceof WordSearchState) {
        if (predecessor != null) {
          loserManager.addAlternatePredecessor(bestToken,predecessor);
        }
      }
    }
  }
}
