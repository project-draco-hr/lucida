{
  Random random=new Random(System.currentTimeMillis());
  Partitioner partitioner=new Partitioner();
  Token parent=new Token(null,0);
  Token[] tokens=new Token[tokenListSize];
  for (int i=0; i < tokens.length; i++) {
    float logTotalScore=random.nextFloat();
    tokens[i]=new Token(parent,null,logTotalScore,0.0f,0.0f,i);
  }
  final int r=partitioner.partition(tokens,tokens.length,absoluteBeamWidth);
  if (tokenListLarger) {
    Assert.assertEquals(r,absoluteBeamWidth - 1);
  }
 else {
    Assert.assertEquals(r,tokenListSize - 1);
  }
  List<Token> firstList=new LinkedList<Token>();
  if (r >= 0) {
    float lowestScore=tokens[r].getScore();
    for (int i=0; i <= r; i++) {
      Assert.assertTrue(tokens[i].getScore() >= lowestScore);
      firstList.add(tokens[i]);
    }
    for (int i=r + 1; i < tokens.length; i++) {
      Assert.assertTrue(lowestScore > tokens[i].getScore());
    }
    Collections.sort(firstList,Scoreable.COMPARATOR);
    List<Token> secondList=Arrays.asList(tokens);
    Collections.sort(secondList,Scoreable.COMPARATOR);
    for (Iterator<Token> i1=firstList.iterator(), i2=secondList.iterator(); i1.hasNext() && i2.hasNext(); ) {
      Token t1=i1.next();
      Token t2=i2.next();
      Assert.assertEquals(t1,t2);
    }
  }
}
