{
  if (!isOpen())   throw new TTransportException(TTransportException.NOT_OPEN,"Must open before seeking");
  int numChunks=getNumChunks();
  if (numChunks == 0) {
    return;
  }
  if (chunk < 0) {
    chunk+=numChunks;
  }
  if (chunk < 0) {
    chunk=0;
  }
  long eofOffset=0;
  boolean seekToEnd=(chunk >= numChunks);
  if (seekToEnd) {
    chunk=chunk - 1;
    try {
      eofOffset=inputFile_.length();
    }
 catch (    IOException iox) {
      throw new TTransportException(iox.getMessage(),iox);
    }
  }
  if (chunk * cs.getChunkSize() != cs.getOffset()) {
    try {
      inputFile_.seek((long)chunk * cs.getChunkSize());
    }
 catch (    IOException iox) {
      System.err.println("createInputStream: " + iox.getMessage());
      throw new TTransportException("Seek to chunk " + chunk + " "+ iox.getMessage(),iox);
    }
    cs.seek((long)chunk * cs.getChunkSize());
    currentEvent_.setAvailable(0);
    inputStream_=createInputStream();
  }
  if (seekToEnd) {
    TailPolicy old=setTailPolicy(TailPolicy.WAIT_FOREVER);
    while (cs.getOffset() < eofOffset) {
      readEvent();
    }
    currentEvent_.setAvailable(0);
    setTailPolicy(old);
  }
}
