def create_pipeline(self, conf):
    self.appsrc = Gst.ElementFactory.make('appsrc', 'appsrc')
    self.decodebin = Gst.ElementFactory.make('decodebin', 'decodebin')
    self.audioconvert = Gst.ElementFactory.make('audioconvert', 'audioconvert')
    self.audioresample = Gst.ElementFactory.make('audioresample', 'audioresample')
    self.tee = Gst.ElementFactory.make('tee', 'tee')
    self.queue1 = Gst.ElementFactory.make('queue', 'queue1')
    self.filesink = Gst.ElementFactory.make('filesink', 'filesink')
    self.queue2 = Gst.ElementFactory.make('queue', 'queue2')
    self.asr = Gst.ElementFactory.make('kaldinnet2onlinedecoder', 'asr')
    self.fakesink = Gst.ElementFactory.make('fakesink', 'fakesink')
    if ('use-threaded-decoder' in conf['decoder']):
        self.asr.set_property('use-threaded-decoder', conf['decoder']['use-threaded-decoder'])
    for (key, val) in conf.get('decoder', {}).iteritems():
        if (key != 'use-threaded-decoder'):
            logger.info(('Setting decoder property: %s = %s' % (key, val)))
            self.asr.set_property(key, val)
    self.appsrc.set_property('is-live', True)
    self.filesink.set_property('location', '/dev/null')
    logger.info('Created GStreamer elements')
    self.pipeline = Gst.Pipeline()
    for element in [self.appsrc, self.decodebin, self.audioconvert, self.audioresample, self.tee, self.queue1, self.filesink, self.queue2, self.asr, self.fakesink]:
        logger.debug(('Adding %s to the pipeline' % element))
        self.pipeline.add(element)
    logger.info('Linking GStreamer elements')
    self.appsrc.link(self.decodebin)
    self.decodebin.connect('pad-added', self._connect_decoder)
    self.audioconvert.link(self.audioresample)
    self.audioresample.link(self.tee)
    self.tee.link(self.queue1)
    self.queue1.link(self.filesink)
    self.tee.link(self.queue2)
    self.queue2.link(self.asr)
    self.asr.link(self.fakesink)
    self.bus = self.pipeline.get_bus()
    self.bus.add_signal_watch()
    self.bus.enable_sync_message_emission()
    self.bus.connect('message::eos', self._on_eos)
    self.bus.connect('message::error', self._on_error)
    self.asr.connect('partial-result', self._on_partial_result)
    self.asr.connect('final-result', self._on_final_result)
    self.asr.connect('full-final-result', self._on_full_final_result)
    logger.info('Setting pipeline to READY')
    self.pipeline.set_state(Gst.State.READY)
    logger.info('Set pipeline to READY')
