{
  score_vect[gid]=logZero;
  for (int j=0; j < comp_size; j++) {
    float logDval=0.0f;
    for (int k=0; k < means_size; k++) {
      int idx=k + means_size * j + gid * comp_size * means_size;
      float logDiff=feat_vect[k] - meansArray[idx];
      logDval+=logDiff * logDiff * precsArray[idx];
    }
    if (logDval != logZero) {
      logDval=logDval * inverseNaturalLogBase;
    }
    int idx2=j + gid * comp_size;
    logDval-=preFactorArray[idx2];
    if (logDval < logZero) {
      logDval=logZero;
    }
    float logVal2=logDval + mixWeightArray[idx2];
    float logHighestValue=score_vect[gid];
    float logDifference=score_vect[gid] - logVal2;
    if (logDifference < 0) {
      logHighestValue=logVal2;
      logDifference=-logDifference;
    }
    float logValue=-logDifference;
    double logInnerSummation;
    if (logValue < minLogValue) {
      logInnerSummation=0.0;
    }
 else     if (logValue > maxLogValue) {
      logInnerSummation=Double.MAX_VALUE;
      System.out.println("enter maxLogValue");
    }
 else {
      if (logValue == logZero) {
        logValue=logZero;
        System.out.println("enter logValue==LogZero");
      }
 else {
        logValue=logValue * naturalLogBase;
      }
      logInnerSummation=Math.exp(logValue);
    }
    logInnerSummation+=1.0;
    float returnLogValue;
    if (logInnerSummation <= 0.0) {
      returnLogValue=logZero;
      System.out.println("enter logInnerSummation <=0.0");
    }
 else {
      returnLogValue=(float)(Math.log(logInnerSummation) * inverseNaturalLogBase);
      if (returnLogValue > Float.MAX_VALUE) {
        returnLogValue=Float.MAX_VALUE;
        System.out.println("enter returnLogValue > MAX_VALUE");
      }
 else       if (returnLogValue < -Float.MAX_VALUE) {
        returnLogValue=-Float.MAX_VALUE;
        System.out.println("enter returnLogValue < -MAX_VALUE");
      }
    }
    score_vect[gid]=logHighestValue + returnLogValue;
  }
}
