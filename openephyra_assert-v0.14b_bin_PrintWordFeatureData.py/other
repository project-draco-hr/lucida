from Iterators import iterfile, itergroup
from ParseTree import ParseTreeFactory
from optparse import OptionParser
import re
import sys
import string
import sets
if (__name__ == '__main__'):
    optionParser = OptionParser(usage='%prog [options] sameerFile svmFile')
    optionParser.add_option('-w', '--words', metavar='WORDS_FILE', action='append', dest='wordFileNames', default=[], help='Append a binary feature for each word in the words file indicating whether or not the constituent contains that word.')
    optionParser.add_option('-c', '--count', metavar='WORDS_FILE', action='append', dest='wordCountFileNames', default=[], help='Append a feature that is the count of words in the constituent occurring in the words file.')
    optionParser.add_option('-s', '--word-score-sum', metavar='WORD_SCORES_FILE', action='append', dest='wordScoreSumFileNames', default=[], help='Append a feature that is the sum of the scores from the file for each word in the constituent (discretized into integers).')
    optionParser.add_option('-p', '--pos-word-score-sum', metavar='POS:WORD_SCORES_FILE', action='append', dest='posPrefixWordScoresFilePairs', default=[], help='Append a feature that is the sum of the scores from the file for each word in the constituent whose part of speech has the given prefix (discretized into integers).')
    optionParser.add_option('-P', '--phrase-type', metavar='PHRASE_TYPE', action='append', dest='phraseTypes', default=[], help='Append a binary feature indicating that the constituent contains this syntactic-phrase-type.')
    (options, args) = optionParser.parse_args()
    if (len(args) != 2):
        optionParser.error('wrong number of arguments')
    (sameerFileName, svmFileName) = args

    def getWords(wordFile):
        words = []
        for line in iterfile(wordFile):
            columns = line.split()
            words.append(columns[0])
        return words

    def getWordScoreMap(wordScoreFile):
        wordScoreMap = {}
        for line in iterfile(wordScoreFile):
            columns = line.split()
            (word, score) = (columns[0], columns[(-1)])
            score = float(score)
            if ((not wordScoreMap.has_key(word)) or (score > wordScoreMap[word])):
                wordScoreMap[word] = score
        return wordScoreMap
    extractors = []
    for wordFileName in options.wordFileNames:
        extractors.append(WordFeatureExtractor(getWords(wordFileName)))
    for wordCountFileName in options.wordCountFileNames:
        extractors.append(WordCountFeatureExtractor(getWords(wordCountFileName)))
    for wordScoreSumFileName in options.wordScoreSumFileNames:
        extractors.append(WordScoreSumFeatureExtractor(getWordScoreMap(wordScoreSumFileName)))
    for posPrefixWordScoresFilePair in options.posPrefixWordScoresFilePairs:
        (posPrefix, wordScoresFileName) = posPrefixWordScoresFilePair.split(':')
        extractors.append(POSWordScoreSumFeatureExtractor(posPrefix, getWordScoreMap(wordScoresFileName)))
    for phraseType in options.phraseTypes:
        extractors.append(PhraseTypeFeatureExtractor(phraseType))
    idMatcher = re.compile('<S TPOS="([^"]*)">')
    idSemanticParseMap = {}
    idSyntacticParseMap = {}
    for (semanticParse, syntacticParse, neLine, blankLine) in itergroup(iterfile(sameerFileName), 4, ''):
        (id,) = idMatcher.findall(semanticParse)
        idSemanticParseMap[id] = semanticParse
        idSyntacticParseMap[id] = syntacticParse
    for line in iterfile(svmFileName):
        if (not line):
            print line
            continue
        columns = line.split()
        (id, begin, end, classVar) = (columns[0], columns[2], columns[3], columns[(-1)])
        (begin, end) = (int(begin), (int(end) + 1))
        if (not idSemanticParseMap.has_key(id)):
            raise Exception, ('no parse for id "%s"' % id)
        (semanticParse, syntacticParse) = (idSemanticParseMap[id], idSyntacticParseMap[id])
        print ' '.join(columns[:(-1)]),
        for extractor in extractors:
            values = extractor.getFeatureValues(begin, end, semanticParse, syntacticParse)
            print ' '.join(map(str, values)),
        print classVar
