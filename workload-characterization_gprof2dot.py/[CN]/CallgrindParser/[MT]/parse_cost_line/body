def parse_cost_line(self, calls=None):
    line = self.lookahead().rstrip()
    mo = self._cost_re.match(line)
    if (not mo):
        return False
    function = self.get_function()
    if (calls is None):
        try:
            self.positions['cob'] = self.positions['ob']
        except KeyError:
            pass
    values = line.split()
    assert (len(values) <= (self.num_positions + self.num_events))
    positions = values[0:self.num_positions]
    events = values[self.num_positions:]
    events += (['0'] * (self.num_events - len(events)))
    for i in range(self.num_positions):
        position = positions[i]
        if (position == '*'):
            position = self.last_positions[i]
        elif (position[0] in '-+'):
            position = (self.last_positions[i] + int(position))
        elif position.startswith('0x'):
            position = int(position, 16)
        else:
            position = int(position)
        self.last_positions[i] = position
    events = [float(event) for event in events]
    if (calls is None):
        function[SAMPLES] += events[0]
        self.profile[SAMPLES] += events[0]
    else:
        callee = self.get_callee()
        callee.called += calls
        try:
            call = function.calls[callee.id]
        except KeyError:
            call = Call(callee.id)
            call[CALLS] = calls
            call[SAMPLES] = events[0]
            function.add_call(call)
        else:
            call[CALLS] += calls
            call[SAMPLES] += events[0]
    self.consume()
    return True
