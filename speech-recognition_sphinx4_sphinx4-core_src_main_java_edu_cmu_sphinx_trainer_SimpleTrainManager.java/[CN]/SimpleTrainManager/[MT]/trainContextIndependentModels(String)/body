{
  UtteranceGraph uttGraph;
  TrainerScore[] score;
  TrainerScore[] nextScore;
  if (learner == null) {
    loadModels(context);
  }
  dumpMemoryInfo("TrainManager start");
  for (  TrainerAcousticModel model : acousticModels) {
    float logLikelihood;
    float lastLogLikelihood=Float.MAX_VALUE;
    float relativeImprovement=100.0f;
    for (int iteration=0; (iteration < maxIteration) && (relativeImprovement > minimumImprovement); iteration++) {
      System.out.println("Iteration: " + iteration);
      model.resetBuffers();
      for (controlFile.startUtteranceIterator(); controlFile.hasMoreUtterances(); ) {
        Utterance utterance=controlFile.nextUtterance();
        uttGraph=new UtteranceHMMGraph(context,utterance,model,unitManager);
        learner.setUtterance(utterance);
        learner.setGraph(uttGraph);
        nextScore=null;
        while ((score=learner.getScore()) != null) {
          for (int i=0; i < score.length; i++) {
            if (i > 0) {
              model.accumulate(i,score,nextScore);
            }
 else {
              model.accumulate(i,score);
            }
          }
          nextScore=score;
        }
        model.updateLogLikelihood();
      }
      logLikelihood=model.normalize();
      System.out.println("Loglikelihood: " + logLikelihood);
      saveModels(context);
      if (iteration > 0) {
        if (lastLogLikelihood != 0) {
          relativeImprovement=(logLikelihood - lastLogLikelihood) / lastLogLikelihood * 100.0f;
        }
 else         if (lastLogLikelihood == logLikelihood) {
          relativeImprovement=0;
        }
        System.out.println("Finished iteration: " + iteration + " - Improvement: "+ relativeImprovement);
      }
      lastLogLikelihood=logLikelihood;
    }
  }
}
