{
  int headerLength=readInt(stream,bigEndian);
  if ((headerLength != DARPA_TG_HEADER.length() + 1) && (headerLength != DARPA_QG_HEADER.length() + 1) && (headerLength != DARPA_NG_HEADER.length() - 1)) {
    headerLength=Utilities.swapInteger(headerLength);
    if (headerLength == (DARPA_TG_HEADER.length() + 1) || headerLength == (DARPA_QG_HEADER.length() + 1) || headerLength == (DARPA_NG_HEADER.length() - 1)) {
      bigEndian=false;
    }
 else {
      throw new Error("Bad binary LM file magic number: " + headerLength + ", not an LM dumpfile?");
    }
  }
 else {
  }
  String header=readString(stream,headerLength - 1);
  stream.readByte();
  bytesRead++;
  if (!header.equals(DARPA_TG_HEADER) & !header.equals(DARPA_QG_HEADER) & !Pattern.matches(DARPA_NG_HEADER,header)) {
    throw new Error("Bad binary LM file header: " + header);
  }
 else {
    if (header.equals(DARPA_TG_HEADER))     maxNGram=3;
 else     if (header.equals(DARPA_QG_HEADER))     maxNGram=4;
 else {
      Pattern p=Pattern.compile("\\d");
      Matcher m=p.matcher(header);
      maxNGram=Integer.parseInt(m.group());
    }
  }
  int fileNameLength=readInt(stream,bigEndian);
  skipStreamBytes(stream,fileNameLength);
  numberNGrams=new int[maxNGram];
  NGramOffset=new long[maxNGram];
  NGramProbTable=new float[maxNGram][];
  NGramBackoffTable=new float[maxNGram][];
  NGramSegmentTable=new int[maxNGram][];
  numberNGrams[0]=0;
  logNGramSegmentSize=LOG2_NGRAM_SEGMENT_SIZE;
  int version=readInt(stream,bigEndian);
  bytesPerField=2;
  if (version <= 0) {
    readInt(stream,bigEndian);
    if (version <= -3)     bytesPerField=4;
    int formatLength;
    for (; ; ) {
      if ((formatLength=readInt(stream,bigEndian)) == 0) {
        break;
      }
      bytesRead+=stream.skipBytes(formatLength);
    }
    if (version == -2) {
      logNGramSegmentSize=readInt(stream,bigEndian);
      if (logNGramSegmentSize < 1 || logNGramSegmentSize > 15) {
        throw new Error("log2(bg_seg_sz) outside range 1..15");
      }
    }
    numberNGrams[0]=readInt(stream,bigEndian);
  }
 else {
    numberNGrams[0]=version;
  }
  if (numberNGrams[0] <= 0) {
    throw new Error("Bad number of unigrams: " + numberNGrams[0] + ", must be > 0.");
  }
  for (int i=1; i < maxNGram; i++) {
    if ((numberNGrams[i]=readInt(stream,bigEndian)) < 0) {
      throw new Error("Bad number of " + String.valueOf(i) + "-grams: "+ numberNGrams[i]);
    }
  }
}
