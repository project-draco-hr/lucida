{
  DataInputStream stream=new DataInputStream(new BufferedInputStream(inputStream));
  readHeader(stream);
  unigrams=readUnigrams(stream,numberNGrams[0] + 1,bigEndian);
  skipNGrams(stream);
  for (int i=1; i < maxNGram; i++) {
    if (numberNGrams[i] > 0) {
      if (i == 1) {
        NGramProbTable[i]=readFloatTable(stream,bigEndian);
      }
 else {
        NGramBackoffTable[i]=readFloatTable(stream,bigEndian);
        NGramProbTable[i]=readFloatTable(stream,bigEndian);
        int nMinus1gramSegmentSize=1 << logNGramSegmentSize;
        int NGramSegTableSize=((numberNGrams[i - 1] + 1) / nMinus1gramSegmentSize) + 1;
        NGramSegmentTable[i]=readIntTable(stream,bigEndian,NGramSegTableSize);
      }
    }
  }
  int wordsStringLength=readInt(stream,bigEndian);
  if (wordsStringLength <= 0) {
    throw new Error("Bad word string size: " + wordsStringLength);
  }
  this.words=readWords(stream,wordsStringLength,numberNGrams[0]);
  if (startWordID > -1) {
    UnigramProbability unigram=unigrams[startWordID];
    unigram.setLogProbability(MIN_PROBABILITY);
  }
  if (endWordID > -1) {
    UnigramProbability unigram=unigrams[endWordID];
    unigram.setLogBackoff(MIN_PROBABILITY);
  }
  applyUnigramWeight();
  if (applyLanguageWeightAndWip) {
    for (int i=0; i <= maxNGram; i++) {
      applyLanguageWeight(NGramProbTable[i],languageWeight);
      applyWip(NGramProbTable[i],wip);
      if (i > 1) {
        applyLanguageWeight(NGramBackoffTable[i],languageWeight);
      }
    }
  }
  stream.close();
}
