{
  int bytesPerSample;
  boolean signedData=true;
  boolean bigEndian;
  AudioFormat.Encoding encoding=audioFormat.getEncoding();
  bytesPerSample=audioFormat.getSampleSizeInBits() / 8;
  if (encoding == AudioFormat.Encoding.PCM_SIGNED) {
    signedData=true;
  }
 else   if (encoding == AudioFormat.Encoding.PCM_UNSIGNED) {
    signedData=false;
  }
 else {
    System.err.println("Unsupported audio encoding: " + encoding);
    System.exit(-1);
  }
  bigEndian=audioFormat.isBigEndian();
  byte[] buffer=new byte[bytesPerSample];
  ArrayList<Short> samples=new ArrayList<Short>();
  int read=0;
  int totalRead=0;
  boolean done=false;
  while (!done) {
    totalRead=read=audioStream.read(buffer,0,bytesPerSample);
    while (totalRead < bytesPerSample) {
      if (read == -1) {
        done=true;
        break;
      }
 else {
        read=audioStream.read(buffer,totalRead,bytesPerSample - totalRead);
        totalRead+=read;
      }
    }
    if (!done) {
      int val=0;
      if (bigEndian) {
        val=buffer[0];
        if (!signedData) {
          val&=0xff;
        }
        for (int i=1; i < bytesPerSample; i++) {
          int temp=buffer[i] & 0xff;
          val=(val << 8) + temp;
        }
      }
 else {
        val=buffer[bytesPerSample - 1];
        if (!signedData) {
          val&=0xff;
        }
        for (int i=bytesPerSample - 2; i >= 0; i--) {
          int temp=buffer[i] & 0xff;
          val=(val << 8) + temp;
        }
      }
      if (!signedData) {
        val=val - (1 << ((bytesPerSample * 8) - 1));
      }
      samples.add((short)val);
    }
  }
  short[] audioData=new short[samples.size()];
  for (int i=0; i < audioData.length; i++) {
    audioData[i]=samples.get(i);
  }
  return audioData;
}
