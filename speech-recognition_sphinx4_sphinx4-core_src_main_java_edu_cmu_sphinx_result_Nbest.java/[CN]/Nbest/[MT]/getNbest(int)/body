{
  lattice.computeNodePosteriors(1.0f);
  HashSet<String> result=new HashSet<String>();
  BoundedPriorityQueue<NBestPath> queue=new BoundedPriorityQueue<Nbest.NBestPath>(n);
  queue.add(new NBestPath("<s>",lattice.getInitialNode(),0,0));
  while (result.size() < n && queue.size() > 0) {
    NBestPath path=queue.poll();
    if (path.node.equals(lattice.terminalNode)) {
      result.add(path.path);
      continue;
    }
    for (    Edge e : path.node.getLeavingEdges()) {
      Node newNode=e.getToNode();
      double newForwardScore=path.forwardScore + e.getAcousticScore() + e.getLMScore();
      double newScore=newForwardScore + newNode.getBackwardScore();
      String newPathString=getNewPathString(path,newNode);
      NBestPath newPath=new NBestPath(newPathString,newNode,newScore,newForwardScore);
      queue.add(newPath);
    }
  }
  return result;
}
