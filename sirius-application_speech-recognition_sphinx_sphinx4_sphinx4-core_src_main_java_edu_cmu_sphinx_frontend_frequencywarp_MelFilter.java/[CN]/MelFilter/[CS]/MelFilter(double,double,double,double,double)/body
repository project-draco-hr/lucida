{
  double filterHeight;
  double leftSlope;
  double rightSlope;
  double currentFreq;
  int indexFilterWeight;
  int numberElementsWeightField;
  if (deltaFreq == 0) {
    throw new IllegalArgumentException("deltaFreq has zero value");
  }
  if ((Math.round(rightEdge - leftEdge) == 0) || (Math.round(centerFreq - leftEdge) == 0) || (Math.round(rightEdge - centerFreq) == 0)) {
    throw new IllegalArgumentException("Filter boundaries too close");
  }
  numberElementsWeightField=(int)Math.round((rightEdge - leftEdge) / deltaFreq + 1);
  if (numberElementsWeightField == 0) {
    throw new IllegalArgumentException("Number of elements in mel" + " is zero.");
  }
  weight=new double[numberElementsWeightField];
  filterHeight=2.0f / (rightEdge - leftEdge);
  leftSlope=filterHeight / (centerFreq - leftEdge);
  rightSlope=filterHeight / (centerFreq - rightEdge);
  for (currentFreq=initialFreq, indexFilterWeight=0; currentFreq <= rightEdge; currentFreq+=deltaFreq, indexFilterWeight++) {
    if (currentFreq < centerFreq) {
      weight[indexFilterWeight]=leftSlope * (currentFreq - leftEdge);
    }
 else {
      weight[indexFilterWeight]=filterHeight + rightSlope * (currentFreq - centerFreq);
    }
  }
  this.initialFreqIndex=(int)Math.round(initialFreq / deltaFreq);
}
